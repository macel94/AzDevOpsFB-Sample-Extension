/* tslint:disable */
/* eslint-disable */
/**
 * WorkItemTracking
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 7.2-preview
 * Contact: nugetvss@microsoft.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AttachmentReference,
  DestroyedAttachment,
} from '../models/index';
import {
    AttachmentReferenceFromJSON,
    AttachmentReferenceToJSON,
    DestroyedAttachmentFromJSON,
    DestroyedAttachmentToJSON,
} from '../models/index';

export interface AttachmentsCreateRequest {
    organization: string;
    project: string;
    apiVersion: string;
    body: string;
    fileName?: string;
    uploadType?: string;
    areaPath?: string;
}

export interface AttachmentsDeleteRequest {
    organization: string;
    id: string;
    project: string;
    apiVersion: string;
}

export interface AttachmentsGetRequest {
    organization: string;
    id: string;
    project: string;
    apiVersion: string;
    fileName?: string;
    download?: boolean;
}

export interface AttachmentsUploadChunkRequest {
    organization: string;
    id: string;
    contentRangeHeader: string;
    project: string;
    apiVersion: string;
    body: string;
    fileName?: string;
}

/**
 * 
 */
export class AttachmentsApi extends runtime.BaseAPI {

    /**
     * Uploads an attachment.  On accounts with higher attachment upload limits (>130MB), you will need to use chunked upload. To upload an attachment in multiple chunks, you first need to [**Start a Chunked Upload**](#start_a_chunked_upload) and then follow the example from the **Upload Chunk** section.
     */
    async attachmentsCreateRaw(requestParameters: AttachmentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AttachmentReference>> {
        if (requestParameters['organization'] == null) {
            throw new runtime.RequiredError(
                'organization',
                'Required parameter "organization" was null or undefined when calling attachmentsCreate().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling attachmentsCreate().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling attachmentsCreate().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling attachmentsCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fileName'] != null) {
            queryParameters['fileName'] = requestParameters['fileName'];
        }

        if (requestParameters['uploadType'] != null) {
            queryParameters['uploadType'] = requestParameters['uploadType'];
        }

        if (requestParameters['areaPath'] != null) {
            queryParameters['areaPath'] = requestParameters['areaPath'];
        }

        if (requestParameters['apiVersion'] != null) {
            queryParameters['api-version'] = requestParameters['apiVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["vso.work_write"]);
        }

        const response = await this.request({
            path: `/{organization}/{project}/_apis/wit/attachments`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters['organization']))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttachmentReferenceFromJSON(jsonValue));
    }

    /**
     * Uploads an attachment.  On accounts with higher attachment upload limits (>130MB), you will need to use chunked upload. To upload an attachment in multiple chunks, you first need to [**Start a Chunked Upload**](#start_a_chunked_upload) and then follow the example from the **Upload Chunk** section.
     */
    async attachmentsCreate(requestParameters: AttachmentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AttachmentReference> {
        const response = await this.attachmentsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Permanently delete an attachment.
     */
    async attachmentsDeleteRaw(requestParameters: AttachmentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyedAttachment>> {
        if (requestParameters['organization'] == null) {
            throw new runtime.RequiredError(
                'organization',
                'Required parameter "organization" was null or undefined when calling attachmentsDelete().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling attachmentsDelete().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling attachmentsDelete().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling attachmentsDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['apiVersion'] != null) {
            queryParameters['api-version'] = requestParameters['apiVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["vso.work_full"]);
        }

        const response = await this.request({
            path: `/{organization}/{project}/_apis/wit/attachments/{id}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters['organization']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyedAttachmentFromJSON(jsonValue));
    }

    /**
     * Permanently delete an attachment.
     */
    async attachmentsDelete(requestParameters: AttachmentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyedAttachment> {
        const response = await this.attachmentsDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Downloads an attachment.
     */
    async attachmentsGetRaw(requestParameters: AttachmentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['organization'] == null) {
            throw new runtime.RequiredError(
                'organization',
                'Required parameter "organization" was null or undefined when calling attachmentsGet().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling attachmentsGet().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling attachmentsGet().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling attachmentsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fileName'] != null) {
            queryParameters['fileName'] = requestParameters['fileName'];
        }

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['apiVersion'] != null) {
            queryParameters['api-version'] = requestParameters['apiVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["vso.work"]);
        }

        const response = await this.request({
            path: `/{organization}/{project}/_apis/wit/attachments/{id}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters['organization']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Downloads an attachment.
     */
    async attachmentsGet(requestParameters: AttachmentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.attachmentsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uploads an attachment chunk.  Before performing [**Upload a Chunk**](#upload-a-chunk), make sure to have an attachment id returned in **Start a Chunked Upload** example on **Create** section. Specify the byte range of the chunk using Content-Length. For example: \"Content - Length\": \"bytes 0 - 39999 / 50000\" for the first 40000 bytes of a 50000 byte file.
     */
    async attachmentsUploadChunkRaw(requestParameters: AttachmentsUploadChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AttachmentReference>> {
        if (requestParameters['organization'] == null) {
            throw new runtime.RequiredError(
                'organization',
                'Required parameter "organization" was null or undefined when calling attachmentsUploadChunk().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling attachmentsUploadChunk().'
            );
        }

        if (requestParameters['contentRangeHeader'] == null) {
            throw new runtime.RequiredError(
                'contentRangeHeader',
                'Required parameter "contentRangeHeader" was null or undefined when calling attachmentsUploadChunk().'
            );
        }

        if (requestParameters['project'] == null) {
            throw new runtime.RequiredError(
                'project',
                'Required parameter "project" was null or undefined when calling attachmentsUploadChunk().'
            );
        }

        if (requestParameters['apiVersion'] == null) {
            throw new runtime.RequiredError(
                'apiVersion',
                'Required parameter "apiVersion" was null or undefined when calling attachmentsUploadChunk().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling attachmentsUploadChunk().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fileName'] != null) {
            queryParameters['fileName'] = requestParameters['fileName'];
        }

        if (requestParameters['apiVersion'] != null) {
            queryParameters['api-version'] = requestParameters['apiVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/octet-stream';

        if (requestParameters['contentRangeHeader'] != null) {
            headerParameters['contentRangeHeader'] = String(requestParameters['contentRangeHeader']);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["vso.work_write"]);
        }

        const response = await this.request({
            path: `/{organization}/{project}/_apis/wit/attachments/{id}`.replace(`{${"organization"}}`, encodeURIComponent(String(requestParameters['organization']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters['project']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttachmentReferenceFromJSON(jsonValue));
    }

    /**
     * Uploads an attachment chunk.  Before performing [**Upload a Chunk**](#upload-a-chunk), make sure to have an attachment id returned in **Start a Chunked Upload** example on **Create** section. Specify the byte range of the chunk using Content-Length. For example: \"Content - Length\": \"bytes 0 - 39999 / 50000\" for the first 40000 bytes of a 50000 byte file.
     */
    async attachmentsUploadChunk(requestParameters: AttachmentsUploadChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AttachmentReference> {
        const response = await this.attachmentsUploadChunkRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
